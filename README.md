# 실전! 코틀린과 스프링 부트로 도서관리 애플리케이션 개발하기 (Java 프로젝트 리팩토링)













POJO(Plain Old Java Object)
- 클래스를 작성하는데 있어서 특별한 규칙이나 제약이 없다.
    - 어떤 클래스를 만드는데 임포트 해야 될 클래스들이 정해져 있고 상속해야 할 부모가 정해져 있고 오버라디이할 메소드나 이런 시그니처들이 픽스가 되어 있다면 그런 클래스들은 규칙이 있고 그 규칙을 반드시 지켜야만 하므로 포조가 아닌 클래스이다
- 일반적으로 부모가 없거나 부모 클ㅐ스를 마음대로 변경할 수 있다.
- POJO가 아닌 기술에 비해 메모리 사용량이 적다

POJO이전의 기술은 애플릿, 서블릿, JSP, EJB 이런 기술들은 POJO가 아니다. 엄청 많은 규칙이나 제약사항이 있고 메모리 사용량이 많기 때문이다.

스프링, 마이바티스 아이바티스, 하이버네이트, JPA 같은 자바 기술들은 포조를 기반으로 한다

예시로 서블릿을 보자
Servlet 클래스 작성 규칙
- jakarta.servlet 혹은 jakarta.servlet.http 패키지의 클래스와 인터페이스를 import 해야 한다.
- public 클래스로 작성해야 한다.
- Servlet이나 GenericServlet 혹은 HttpServlet 클래스를 상속해야 한다.
- 기본 생성자가 있어야 한다.
- 라이프 사이클에 해당하는 Callback 메소드들을 적절하게 재정의(Overriding) 해야 한다. 
```
// 1. import를 해야 한다 - import가 안되어 있으면 컴파일이 안 된다
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;

// 2. public class로 작성해야 한다 - public 클래스가 아니면 이 클래스를 서버가 인지하지 못할 것이다.
public class HelloServlet extends HttpServlet { // 3. HttpServlet로 부모 클래스가 고정되어 있다 - 부모 클래스를 지워버리면 컴파일은 되나 실행이 안 된다
    private static final long serialVersionUID = 1L;
    
    public HelloServlet() { // 반드시 디폴트 생성자가 있어야 한다 - 디폴트 생성자가 없으면 에러가 난다. 반드시 필요하다
        super();
    }
    
    // 콜백 메서드로 불리우는 메서드들이 overriding되어 있어야 한다 - 서버가 호출해주는 서비스라고 하는 콜백 메서드인데 메서드 이름 또는 매개변수 또는 리턴 타입이 다르면 오버라이딩이 아니기 때문에 에러가 난다
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    
    }
    // service() 메서드가 호출되려면 request 객체와 response의 객체가 반드시 생성돼서 메서드가 호출될 떄 인자로 전달되어야 한다
    // 그런데 써먹지를 않는데 객체를 받아서 메모리 낭비만 하면 안되지만 request, response 객체를 지워버리면 오버라이딩이 아닌게 되고 오버라이딩을 안 했을 때는 실행이 되지 않는다.
    // 호출해서 사용하든 그렇지 안든 무조건 매개변수로 HttpServletRequest와 HttpServletResponse를 받아야만 한다. 그래야 정상적으로 서블릿이 실행되기 때문이다
}
```
POJO가 아닌 클래스는 자바 기술 (EJB)들은 복잡한 규칙이 있다

스프링이 사용하는 POJO
```
public class HelloServlet {
    protected void anyThing() {
        
    }
}
```
클래스를 내 마음대로 만들 수 있다. 메서드 이른, 리턴 타입, 매개변수 메서드 시그니처 등등 클래스를 내 마음대로 만들 수 있기 떄문에 규칙이 없다. 그래서 배우기 쉽고 메서드 매개변수 내 마음대로 결정할 수 있기 때문에 사용하지 않는 그런 객체를 쓸데없이, 사용하지도 않을 것을 매개변수로 받을 필요도 없다. 이것이 POJO이다.


Spring은 POJO (Plain Old Java Object, 자바로 생성하는 순수한 객체)를 기반으로 한다. 이를 통해, 객체 지향적인 원리에 충실하면서, 환경과 기술에 종속되지 않고, 필요에 따라 재활용할 수 있게 됐다. 그 이외에도 BeanFactory, ApplicationContext, DI (의존관게 주입), IOC(제어의 역전), AOP (관점 지향 프로그래밍) 을 통해 개발 생산성을 높였다.

POJO는 특정 기술이나 프레임워크에 종속되지 않고, 자바의 객체 지향 원칙을 따르면서 재사용 가능하도록 설계된 순수한 자바 오브젝트를 의미하며, 스프링 프레임워크는 이러한 POJO 기반으로 엔터프라이즈 서비스 기능을 제공하는 것을 목표로 합니다.
POJO의 특징
순수함 (Plain):
특정 기술이나 프레임워크에 종속되지 않고, 일반적인 자바 언어로 작성됩니다.
간단함 (Old):
객체 지향의 원리에 충실하여 복잡한 기술적 의존성 없이 비즈니스 로직 구현에 집중할 수 있도록 설계됩니다.
자바 오브젝트 (Java Object):
자바의 표준 기능을 사용하여 개발되며, 기술적인 복잡성을 줄이고 재활용성을 높입니다.
스프링에서의 POJO
목표:
복잡한 엔터프라이즈 서비스 기술을 POJO에 제공하여, 애플리케이션 핵심 로직의 기술적 복잡성을 제거하고 비즈니스 로직에만 집중할 수 있도록 돕습니다.
지원 기술:
스프링은 POJO 프로그래밍을 지원하기 위해 IoC/DI (제어의 역전/의존관계 주입), AOP (관점 지향 프로그래밍), PSA (Portable Service Abstraction) 등의 기술을 제공합니다.
장점:
EJB와 같은 기존 기술의 단점(프레임워크/서버 환경 의존성)을 극복하고, 유연하고 확장 가능한 애플리케이션 개발을 가능하게 합니다.

Plain Old Java Object, 간단히 POJO는 말 그대로 해석을 하면 오래된 방식의 간단한 자바 오브젝트라는 말로서 Java EE 등의 중량 프레임워크들을 사용하게 되면서 해당 프레임워크에 종속된 "무거운" 객체를 만들게 된 것에 반발해서 사용되게 된 용어이다. 2000년 9월에 마틴 파울러, 레베카 파슨, 조쉬 맥킨지 등이 사용하기 시작한 용어로서 마틴 파울러는 다음과 같이 그 기원을 밝히고 있다. [1]

“	우리는 사람들이 자기네 시스템에 보통의 객체를 사용하는 것을 왜 그렇게 반대하는지 궁금하였는데, 간단한 객체는 폼 나는 명칭이 없기 때문에 그랬던 것이라고 결론지었다. 그래서 적당한 이름을 하나 만들어 붙였더니, 아 글쎄, 다들 좋아하더라고.	”

— 마틴 파울러
POJO라는 용어는 이후에 주로 특정 자바 모델이나 기능, 프레임워크 등을 따르지 않은 자바 오브젝트를 지칭하는 말로 사용되었다. 스프링 프레임워크는 POJO 방식의 프레임워크이다.

Plain Old Java Object, 간단히 POJO는 말 그대로 해석을 하면 오래된 방식의 간단한 자바 오브젝트라는 말로서 Java EE 등의 중량 프레임워크들을 사용하게 되면서 해당 프레임워크에 종속된 "무거운" 객체를 만들게 된 것에 반발해서 사용되게 된 용어이다.

POJO(Plain Old Java Object)는 복잡한 EJB(Enterprise JavaBeans)의 기술 종속성을 벗어나, 객체지향의 장점을 살리면서 객체의 핵심 로직만 남기기 위해 등장했습니다. POJO는 특정 기술이나 프레임워크에 의존하지 않고 순수한 자바 객체로써, 코드의 가독성, 재사용성, 테스트 용이성, 유지보수성을 높이는 것이 주된 목적입니다. 마틴 파울러가 EJB보다 단순한 객체를 활용하는 장점이 있는데도 사람들이 꺼려하는 이유가 "그럴듯한 이름이 없기 때문"이라고 생각하여 POJO라는 용어를 만들었습니다.
POJO가 생겨난 배경
EJB의 복잡성:
당시 엔터프라이즈 애플리케이션 개발에 주로 사용되던 EJB는 특정 기술 스펙에 종속되어 코드가 복잡하고 의존성이 높았습니다.
기술 종속성 문제:
EJB와 같은 특정 기술에 의존하는 코드는 유연성이 떨어지고, 재활용이 어려우며, 테스트하기도 까다로워지는 단점이 있었습니다.
객체지향 원리 위배:
복잡한 기술에 얽매이면서 자바 객체가 본연의 객체지향적 장점을 잃어가고 있다는 문제점이 제기되었습니다.
POJO의 등장 목적
순수한 자바 객체:
특정 기술에 종속되지 않고 순수한 자바 객체로서 비즈니스 로직을 담는 것을 목표로 합니다.
객체지향의 장점 보존:
객체지향 설계 원칙을 충실히 따르면서도, 특정 기술에 얽매이지 않는 유연하고 재활용 가능한 코드를 작성하도록 돕습니다.
가독성 및 유지보수성 향상:
코드가 간결해지고 의존성이 줄어들어 코드의 가독성이 높아지고 유지보수가 쉬워집니다.
테스트 용이성:
특정 기술에 종속되지 않아 단위 테스트를 작성하기 용이하며, 이는 코드 품질 향상으로 이어집니다.
마틴 파울러의 명명:
마틴 파울러가 '평범한 자바 객체'라는 의미를 부여함으로써, 사람들이 단순한 자바 객체를 사용하는데 긍정적인 인식을 갖도록 유도했습니다.